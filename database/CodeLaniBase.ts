import { jtree } from "jtree"
import { codelaniNodeKeywords } from "./types"
import {
  nodeToFlatObject,
  getJoined,
  getPrimaryKey,
  isLanguage,
  getCleanedId
} from "./utils"

const lodash = require("lodash")
const { TreeNode } = jtree
const {
  TreeBaseFolder,
  TreeBaseFile,
  TreeBaseServer
} = require("jtree/products/treeBase.node.js")
const { Disk } = require("jtree/products/Disk.node.js")

const typeNames = new TreeNode(`application
assembly assembly language
binaryDataFormat
binaryExecutable binary executable format
bytecode bytecode format
characterEncoding
cloud cloud service
compiler
editor
esolang esoteric programming language
filesystem
framework
grammarLanguage
idl interface design language
interpreter
ir intermediate representation language
isa instruction set architecture
jsonFormat
library
linter
metalanguage
notation
os operating system
packageManager
pattern design pattern
pl programming language
plzoo minilanguage
protocol
queryLanguage
schema
standard
stylesheetLanguage
template template language
textData text data format
textMarkup text markup language
visual visual programming language
vm virtual machine
webApi
xmlFormat`).toObject()

class CodeLaniFile extends TreeBaseFile {
  get primaryKey() {
    return getPrimaryKey(this)
  }

  get link() {
    return `<a href="${this.primaryKey}.html">${this.primaryKey}</a>`
  }

  private _title: string

  get title() {
    if (!this._title) this._title = this.get("title") || this.primaryKey
    return this._title
  }

  get isLanguage() {
    return isLanguage(this.get("type"))
  }

  get numberOfUsers() {
    return this.getParent().predictNumberOfUsers(this)
  }

  get numberOfJobs() {
    return this.getParent().predictNumberOfJobs(this)
  }

  get percentile() {
    return this.getParent().predictPercentile(this)
  }

  get languageRank() {
    return this.getParent().getLanguageRank(this)
  }

  get extensions() {
    return getJoined(this, [
      "fileExtensions",
      "githubLanguage fileExtensions",
      "wikipedia fileExtensions"
    ])
  }

  get typeName() {
    let type = this.get("type")
    type = typeNames[type] || type
    return lodash.startCase(type).toLowerCase()
  }

  get base() {
    return this.getParent() as CodeLaniBaseFolder
  }

  get linksToOtherFiles() {
    const programParser = this.base.grammarProgramConstructor
    const program = new programParser(this.childrenToString())
    return program
      .findAllWordsWithCellType("permalinkCell")
      .map(word => word.word)
  }

  // todo: move upstream to Grammar
  formatAndSave() {
    const original = this.childrenToString()
    const noBlankLines = original.replace(/\n\n+/g, "\n")
    const programParser = this.base.grammarProgramConstructor
    const program = new programParser(noBlankLines)

    program.sort((nodeA, nodeB) => {
      const a = nodeA.sortIndex ?? 0
      const b = nodeB.sortIndex ?? 0
      return a > b ? -1 : a < b ? 1 : nodeA.getLine() > nodeB.getLine()
    })

    // pad sections
    program
      .filter(node => node.padOnFormat)
      .forEach(node => {
        if (node.getPrevious().getLine() !== "") node.prependSibling("")
        if (node.getNext().getLine() !== "") node.appendSibling("")
      })

    this.setChildren(program.toString())
    this.save()
  }
}

class CodeLaniBaseFolder extends TreeBaseFolder {
  createParser() {
    return new TreeNode.Parser(CodeLaniFile)
  }

  get patternFiles() {
    return this.filter(file => file.get("type") === "pattern")
  }

  get grammarProgramConstructor() {
    if (!this._grammarProgramConstructor)
      this._grammarProgramConstructor = new jtree.HandGrammarProgram(
        Disk.read(this._getDir() + "codelani.grammar")
      ).compileAndReturnRootConstructor()

    return this._grammarProgramConstructor
  }

  _inboundLinks: any
  get inboundLinks() {
    if (this._inboundLinks) return this._inboundLinks

    const inBoundLinks = {}
    this.forEach(file => {
      inBoundLinks[file.primaryKey] = []
    })

    this.forEach(file => {
      file.linksToOtherFiles.forEach(link => {
        if (!inBoundLinks[link])
          console.error(
            `Broken permalink in '${file.primaryKey}': No language "${link}" found`
          )
        else inBoundLinks[link].push(file.primaryKey)
      })
    })

    this._inboundLinks = inBoundLinks
    return this._inboundLinks
  }

  get typesFile() {
    // Build the types file
    // interface codelaniNode
    const gpc = this._grammarProgramConstructor
    const tsContent =
      "// Autogenerated from Grammar\n\n" +
      new gpc()
        .getDefinition()
        .toTypeScriptInterface()
        .replace("interface codelaniNode", "export interface codelaniNode")
    return tsContent
  }

  _searchIndex?: Map<string, string>
  get searchIndex() {
    if (this._searchIndex) return this._searchIndex
    const map = new Map()
    this.forEach(file => {
      const id = file.primaryKey
      map.set(file.primaryKey, id)
      map.set(file.title, id)
      const wp = file.get("wikipedia")
      if (wp) map.set(wp.replace("https://en.wikipedia.org/wiki/", ""), id)
    })
    this._searchIndex = map
    return this._searchIndex
  }

  searchForEntity(query) {
    const { searchIndex } = this
    return searchIndex.get(query) || searchIndex.get(getCleanedId(query))
  }

  predictNumberOfUsers(file) {
    return Math.round(
      this._computeMetric(file, [
        "linkedInSkill peopleWithThisSkillCount",
        li => parseInt(li.split(" ")[0]) + 12,
        "meetup members",
        rank => parseInt(rank),
        "subreddit memberCount 2017",
        value => parseInt(value),
        "projectEuler members 2022",
        value => parseInt(value),
        codelaniNodeKeywords.wikipedia,
        value => 20,
        "patterns hasCentralPackageRepository?",
        value => 1000,
        "wikipedia dailyPageViews",
        count => 100 * (parseInt(count) / 20), // say its 95% bot traffic, and 1% of users visit the wp page daily
        "linguistGrammarRepo", // According to https://github.com/github/linguist/blob/master/CONTRIBUTING.md, linguist indicates a min of 200 users.
        value => 200,
        "codeMirror",
        value => 50,
        codelaniNodeKeywords.website,
        value => 5,
        codelaniNodeKeywords.githubRepo,
        value => 5,
        "githubRepo forks",
        value => value * 3,
        "githubRepo stars",
        count => parseInt(count)
      ]).score
    )
  }

  _computeMetric(file, criteria) {
    const keys = criteria.filter((item, i) => i % 2 === 0)
    const fns = criteria.filter((item, i) => i % 2 === 1)
    const values = keys.map(key => file.get(key))
    const score = Math.round(
      values
        .map((value, index) => (value ? fns[index](value) : 0))
        .reduce((a, b) => a + b, 0)
    )
    return { id: file.primaryKey, score }
  }

  predictNumberOfJobs(file) {
    const li =
      parseInt(file.get("linkedInSkill peopleWithThisSkillCount") || 0) * 0.01
    const indeed = parseInt(file.get("indeedJobs 2017") || 0)
    return Math.round(li + indeed)
  }

  // Rank is:
  // numberOfUsersRank + numberOfJobsRank + factCountRank + numInboundLinks
  // todo: add a pagerank like element
  _calcRanks(files = this.getChildren()) {
    const { inboundLinks } = this
    let objects = files.map(file => {
      const id = file.primaryKey
      const object: any = {}
      object.id = id
      object.jobs = this.predictNumberOfJobs(file)
      object.users = this.predictNumberOfUsers(file)
      object.factCount = file.length
      object.inBoundLinkCount = inboundLinks[id].length
      return object
    })
    objects = lodash.sortBy(objects, ["jobs"])
    objects.reverse()
    objects.forEach((obj, rank) => (obj.jobRank = rank))

    objects = lodash.sortBy(objects, ["users"])
    objects.reverse()
    objects.forEach((obj, rank) => (obj.userRank = rank))

    objects = lodash.sortBy(objects, ["factCount"])
    objects.reverse()
    objects.forEach((obj, rank) => (obj.factCountRank = rank))

    objects = lodash.sortBy(objects, ["inBoundLinkCount"])
    objects.reverse()
    objects.forEach((obj, rank) => (obj.inBoundLinkRank = rank))

    objects.forEach(
      (obj, rank) =>
        (obj.totalRank =
          obj.jobRank + obj.userRank + obj.factCountRank + obj.inBoundLinkRank)
    )
    objects = lodash.sortBy(objects, ["totalRank"])

    const ranks = {}
    objects.forEach((obj, index) => (ranks[obj.id] = index))
    return ranks
  }

  _ranks: any
  _languageRanks: any
  _getRanks(files = this.getChildren()) {
    if (!this._ranks) {
      this._ranks = this._calcRanks(files)
      this._languageRanks = this._calcRanks(
        files.filter(file => file.isLanguage)
      )
    }
    return this._ranks
  }

  predictPercentile(file) {
    const files = this.getChildren()
    const ranks = this._getRanks(files)
    return ranks[file.primaryKey] / files.length
  }

  getLanguageRank(file) {
    this._getRanks()
    return this._languageRanks[file.primaryKey]
  }

  getRank(file) {
    const ranks = this._getRanks()
    return ranks[file.primaryKey]
  }

  toObjectsForCsv() {
    // todo: sort columns by importance
    const program = this.toProgram()
    program.getTopDownArray().forEach(node => {
      if (node.includeChildrenInCsv === false) node.deleteChildren()
      if (node.getNodeTypeId() === "blankLineNode") node.destroy()
    })
    program.forEach(node => {
      node.set("id", getPrimaryKey(node))
    })
    const objects = program.map(nodeToFlatObject)
    const ranks = this._getRanks()
    // Add ranks
    objects.forEach(obj => {
      obj.rank = ranks[obj.id]
    })

    return lodash.sortBy(objects, "rank")
  }

  startServer(port) {
    this.buildGrammar()
    this.loadFolder()
    this.startListeningForFileChanges()
    new TreeBaseServer(this).listen(port)
  }
}

export { CodeLaniBaseFolder, CodeLaniFile }
